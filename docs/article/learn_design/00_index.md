# 设计模式

设计模式是软件工程中用来解决特定问题的一组解决方案。它们是经过验证的、可重用的解决方案，可以在不同的软件项目中应用。

## **创建型模式**（Creational Patterns）

- **单例模式**（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
- **工厂方法模式**（Factory Method）：定义创建对象的接口，让子类决定实例化哪一个类。
- **抽象工厂模式**（Abstract Factory）：创建相关或依赖对象的家族，而不需明确指定具体类。
- **建造者模式**（Builder）：构建一个复杂的对象，并允许按步骤构造。
- **原型模式**（Prototype）：通过拷贝现有的实例创建新的实例，而不是通过新建。

## **结构型模式**（Structural Patterns）

- **适配器模式**（Adapter）：允许对象间的接口不兼容问题通过一个中间层来解决。
- **装饰器模式**（Decorator）：动态地给一个对象添加额外的职责。
- **代理模式**（Proxy）：为另一个对象提供一个代替或占位符以控制对它的访问。
- **外观模式**（Facade）：为子系统中的一组接口提供一个统一的高层接口。
- **桥接模式**（Bridge）：将抽象部分与其实现部分分离，使它们可以独立地变化。
- **组合模式**（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构。
- **享元模式**（Flyweight）：通过共享来高效地支持大量细粒度的对象。

## **行为型模式**（Behavioral Patterns）

- **策略模式**（Strategy）：定义一系列算法，把它们一个个封装起来，并使它们可互换。
- **模板方法模式**（Template Method）：在方法中定义算法的骨架，延迟到子类中实现。
- **观察者模式**（Observer）：对象间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。
- **迭代器模式**（Iterator）：顺序访问一个聚合对象中的各个元素，不暴露其内部的表示。
- **责任链模式**（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
- **命令模式**（Command）：将请求封装为一个对象，从而使用户可用不同的请求对客户进行参数化。
- **备忘录模式**（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
- **状态模式**（State）：允许一个对象在其内部状态发生改变时改变其行为。
- **访问者模式**（Visitor）：为一个对象结构（如组合结构）增加新能力。
